#!/bin/sh
# Copyright Â© 2014-2015 Cyril Vechera http://jet9.net
# All rights reserved.
# 
# BSD-2
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


## Core functions
#
#   dependency_init() - prepare FIFO mutexes for all tasks, all mutexes are assumed initially locked
#   dependency_wait() - wait on the mutexes for the tasks listed
#   dependency_mark() - mark (broadcast release) the mutexes of the tasks listed
#   dependency_run()  - run task: wait on WAIT mutexes, run the task, release the MARK mutexes

dependency_init() {
	local name
	for name in "$@"; do
		rm -f "$LOCK_DIR/$name"
		mkfifo "$LOCK_DIR/$name"
	done
}

dependency_wait() {
	local name none
	for name in "$@"; do
		read none < "$LOCK_DIR/$name"
	done 2>&-
}

dependency_mark() {
	local name
	for name in "$@"; do
		mv "$LOCK_DIR/$name" "$LOCK_DIR/$name.done"
		: <> "$LOCK_DIR/$name.done" 
		rm -f "$LOCK_DIR/$name.done"
	done
}

dependency_run() {
	local wait="$1" mark="$2" task=$3 action=$4 id

	id="$wait -> $mark"

	verbose "task: $task, wait: $wait, ($id)"
	dependency_wait $wait

	if [ -n "$task" ]; then
		if [ -z "$dry_run" ]; then
			verbose "task: $task, action: $action, ($id)"
			task_execute $task $action
		fi
	fi

	dependency_mark $mark
	verbose "task: $task, mark: $mark, ($id)"
}

## Implementation functions
#
# This layer is implementation specific and the functions can be redefined
# for other purposes.


# Execute script keeping it's pid to kill the script if needed
# This function can be redefined to execute a task in another mode,
# i.e. as a shell function, or shell script sourced and executed in subshell,
# or calling some program and passing task and action to it etc.

task_execute() {
	local task=$1 action=$2
	local script

	terminated() {
		info "task $1 terminated"
		if [ -n "$scriptpid" ]; then
			verbose "kill script $1 with pid $scriptpid"
			kill $scriptpid
		fi
	}

	eval script=\$path_$task
	output "$script"

	# dual trap used to echo output from normal exit context, where stderr is not closed
	trap "trap 'terminated $script' EXIT; exit" INT TERM

	# run script with action argument, save it's pid to kill it if needed, and wait for complete
	"$script" $args &
	scriptpid=$!
	wait
}

# Get dependencties for all relations of the task and action

task_dependencies_relations() {
	local task=$1 action=$2 dependency tasks
	for relation in wait lead mark; do
		task_dependencies $task $action $relation
		verbose "dependencies for task $task, $relation: $task_dependencies_result"
		eval task_dependencies_relations_result_$relation=\"$task_dependencies_result\"
	done
}

# Get wait and mark dependencies for task
#
# arguments: relation (wait|lead|mark), task, action, script_path
# result must be assigned to "wait_$task" variable
#
# The function can be redefined to extract script dependencies by another
# ways, i.e. with awk search for keywords in a script headers and so on.

task_dependencies() {
	local task=$1 action=$2 relation=$3
	local script dependency dependencies
	task_dependencies_result=
	eval script=\$path_$task
	if [ -x $script ]; then
		dependencies=$($script $relation $action)
		for dependency in $dependencies; do
			task_internal $dependency
			task_dependencies_result="$task_dependencies_result $task_internal_result"
		done
	fi
}

# Rewrite task name to the name suitable for internal purpose, mainly to
# use it in a shell variables name.
# The function replaces all hypens and dots to underscores.
# Return result via shared variable 'task_internal_result'.

task_internal() {
	local IFS='-.' part
	set $1
	task_internal_result=$1
	shift
	for part in $*; do
		task_internal_result="${task_internal_result}_${part}"
	done
}

## Auxiliary runtime functions

verbose() {
	[ -n "$verbose" ] && info "$*"
}

info() {
	echo "$*" >&2
}

output() {
	echo "$*"
}


## CLI
#
# Parse command line, find scripts, resolve tasks dependencies and run the batch

jet9_multitask_init() {

	err_exit() {
		echo "$1" >&2
		exit ${2:-1}
	}

	usage() {
		err_exit "Usage: $(basename $0) [-a] [-i include_source] [-n] [-v] [-d] action [tasks ...]

Arguments:
	-a       - add all WAIT-dependent tasks to run list
	-i       - include another shell script source
	-n       - dry run
	-v       - verbose
	-d       - output dependencies for action, can be used for 'tsort'
			   to check for problems
	action   - start, stop or another action
	tasks    - task scripts from INIT_DIR;
			   all scripts from INIT_DIR used if tasks are omitted

Environment:
	INIT_DIR=${INIT_DIR}
	LOCK_DIR=${LOCK_DIR}"
	}

	: ${INIT_DIR:='/own/etc/init'}
	: ${LOCK_DIR:='/run/init'}

	while getopts anvdi: opt
	do
		case "$opt" in
			a) auto_add=1 ;;
			i) include_source="${include_source} $OPTARG" ;;
			n) dry_run=1 ;;
			v) verbose=1 ;;
			d) dependencies=1 ;;
			*) usage ;;
		esac
	done

	shift $(($OPTIND - 1))

	# Include another source. Can be used to redefine dependency_* functions or program flags.

	for source in $include_source; do
		verbose "include $source"
		. $source
	done

	# Get action and tasks

	[ $# -ge 1 ] || usage

	action=$1
	shift

	# If INIT_DIR is set, check existence of all directories
	if [ -n "$INIT_DIR" ]; then
		for dir in $INIT_DIR; do
			[ -d $dir ] || err_exit "not a directory $dir"
		done
	fi

	# If tasks omitted or auto add is on, find all available scripts and add them to allowed scripts

	scripts=
	if [ $# -eq 0 -o -n "$auto_add" ]; then
		for dir in $INIT_DIR; do
			for script in $dir/*; do
				[ -x "$script" ] || continue # Process only executable scripts
				scripts="$scripts $script"
			done
		done
	else
		for script in "$@"; do
			case $script in
			/*)
				[ -x "$script" ] || err_exit "script $script not found"
				scripts="$scripts $script"
				;;
			*)
				for dir in $INIT_DIR; do
					path=$dir/$script
					[ -x "$path" ] && break
					path=
				done
				[ -n "$path" ] || err_exit "script $script not found"
				scripts="$scripts $path"
				;;
			esac
		done
	fi


	# Build mapping of a task's internal name to the task's script path

	allowed_tasks=
	for script in $scripts; do
		name=${script##*/}
		task_internal $name
		eval path_$task_internal_result=$script
		allowed_tasks="$allowed_tasks $task_internal_result"
	done


	# Get WAIT, LEAD and MARK names from allowed tasks

	for task in $allowed_tasks; do
		task_dependencies_relations $task $action

		eval wait_$task="\$task_dependencies_relations_result_wait"
		eval lead_$task="\$task_dependencies_relations_result_lead"
		eval mark_$task="\$task_dependencies_relations_result_mark"
	done

	# Prepare virtual tasks (defined only by marks and without corresponding script)

	for task in $allowed_tasks; do
		eval task_marks=\$mark_$task
		for mark in $task_marks; do
			[ "$task" = "$mark" ] && continue
			eval mark_tasks=\$mark_tasks_$mark
			[ -z "$mark_tasks" ] && marks="$marks $mark"
			eval mark_tasks_$mark=\"$mark_tasks $task\"
		done
	done

	# Build running tasks list

	if [ $# -eq 0 ]; then
		# no task in argument, use all allowed tasks from all dirs in INIT_DIR
		tasks=$allowed_tasks
	else
		# use tasks from arguments
		tasks=
		for script in "$@"; do
			name=${script##*/}
			task_internal $name
			tasks="$tasks $task_internal_result"
		done
		if [ -n "$auto_add" ]; then
			# add dependent tasks
			verbose "auto add tasks"
			curr_tasks=$tasks
			tasks=
			marks=
			while [ -n "$curr_tasks" ]; do
				next_tasks=
				# check WAIT dependencies and add them to running task list
				for task in $curr_tasks; do
					eval checked=\$checked_$task
					[ -z "$checked" ] || continue
					eval mark_tasks=\$mark_tasks_$task
					if [ -z "$mark_tasks" ]; then
						# real task
						tasks="$tasks $task"
						eval next_tasks=\"\$next_tasks \$wait_$task\"
					else
						# virtual task (tasks for MARK)
						marks="$marks $task"
						next_tasks="$next_tasks $mark_tasks"
					fi
					eval checked_$task=1
				done
				curr_tasks=$next_tasks
			done
		fi
	fi

	verbose "tasks: $tasks"


	# Add leading tasks to wait lists

	for task in $tasks; do
		eval lead=\"\$lead_$task\"
		for name in $lead; do
			eval mark_tasks=\$mark_tasks_$name
			if [ -n "$mark_tasks" ]; then
				# virtual task (tasks for MARK)
				for mark_task in  $mark_tasks; do
					eval wait_$mark_task=\"\$wait_$mark_task $task\"
				done
			else
				# real task
				eval wait_$name=\"\$wait_$name $task\"
			fi
		done
	done

	# Dump dependencies for -d option

	if [ -n "$dependencies" ]; then
		# tasks with scripts
		for task in $tasks; do
			eval wait=\"\$wait_$task\"
			for name in $wait; do
				output "$task $name"
			done
		done

		# virtuals tasks, from marks
		for mark in $marks; do
			eval wait=\"\$mark_tasks_$mark\"
			for name in $wait; do
				output "$mark $name"
			done
		done
		exit 0
	fi


	# Check, lock and run all tasks

	[ -d "$LOCK_DIR" ] && err_exit "$LOCK_DIR already exists"

	# atomic mkdir to ensure sole run

	mkdir "$LOCK_DIR" 2>&- || err_exit "can't create $LOCK_DIR"

	echo $$ > "$LOCK_DIR/init.pid"

	dependency_init $tasks $marks

	taskpids=

	# run tasks with scripts
	for task in $tasks; do
		(
			eval wait=\"\$wait_$task\"
			dependency_run "$wait" "$task" "$task" "$action"
		) &
		taskpids="$taskpids $!"
	done

	# run virtuals tasks, from marks
	for mark in $marks; do
		(
			eval wait=\"\$mark_tasks_$mark\"
			dependency_run "$wait" "$mark"
		) &
		taskpids="$taskpids $!"
	done

	cleanup() {
		trap '' EXIT INT TERM

		# kill all tasks
		kill -TERM $taskpids 2>&-

		# remove run data
		rm -f "$LOCK_DIR/init.pid"
		rmdir "$LOCK_DIR"
	}

	trap cleanup EXIT INT TERM

	# wait all them complete

	verbose "wait"
	wait

	verbose "done"
}

# Check JET9_MULTITASK_INIT_CLI_DISABLE and run command if not
# To use jet9_multitask_init only as library, set JET9_MULTITASK_INIT_CLI_DISABLE
# before loading via . source

if [ -z "$JET9_MULTITASK_INIT_CLI_DISABLE" ]; then
	jet9_multitask_init "$@"
else
	unset JET9_MULTITASK_INIT_CLI_DISABLE
fi
